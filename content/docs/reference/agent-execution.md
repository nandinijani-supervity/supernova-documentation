---
title: "Agent Execution APIs"
description: "Execute and interact with Supervity AI agents programmatically"
category: "Reference"
order: 2
---

# Agent Execution APIs

This guide explains how to **execute Supervity AI agents programmatically** using APIs.

Use these APIs when you want to:
- trigger agents from external systems
- pass structured inputs to agents
- monitor execution state and outputs
- embed Supervity agents into your product or backend

If you are coming from **API Reference**, this document explains the **agent execution model in practice**.

---

## Execution Model (Important)

Before calling the APIs, it’s important to understand how execution works in Supervity.

### Core Concepts

- **Agent**  
  An AI operator that reasons, plans, and governs execution

- **Workflow**  
  The deterministic execution graph generated by an agent

- **Run (Job)**  
  A single execution instance of a workflow

### From an API Perspective

- you trigger **execution**
- supervity creates a **run**
- the run executes the **agent-backed workflow**
- you observe **state, logs, and outputs**

You never execute an agent “directly” — you always create a **run**.

---

## Executing an Agent

Agent execution is performed using the workflow execution endpoint.

### Endpoint

**POST** `/api/v1/workflow-runs/execute`

Although the endpoint references a workflow ID, all executions are:
- agent-backed
- governed by policies
- subject to approvals and permissions

---

## Request Format

### Required Fields

- `workflowId` (string)  
  The ID of the workflow generated by an agent.

---

### Inputs & Payloads

Inputs are sent using `multipart/form-data`.

Supported input types:
- strings
- numbers
- booleans
- files
- arrays
- structured objects (json-encoded)

#### Example: Simple Inputs

```bash
curl -X POST "$SUPERVITY_API_URL/api/v1/workflow-runs/execute" \
  -H "Authorization: Bearer $SUPERVITY_TOKEN" \
  -F "workflowId=workflow_123" \
  -F "inputs[query]=Summarize this document" \
  -F "inputs[max_tokens]=300"
````

---

### File Inputs

```bash
curl -X POST "$SUPERVITY_API_URL/api/v1/workflow-runs/execute" \
  -H "Authorization: Bearer $SUPERVITY_TOKEN" \
  -F "workflowId=workflow_123" \
  -F "inputs[document]=@./contract.pdf"
```

Files are scoped to the run and are not persisted beyond execution unless explicitly stored by a workflow step.

---

## Execution Behavior

When a run is created:

1. inputs are validated
2. workflow definition is loaded
3. agent governance rules are applied
4. execution begins step-by-step
5. execution may pause for human review
6. execution completes or fails safely

Execution **never bypasses**:

* approval steps
* role permissions
* integration access controls
* policy constraints

---

## Execution Responses

### Immediate Response

The execute endpoint is **asynchronous**.

A successful request returns metadata indicating the run has started.

```json
{
  "runId": "run_abc123",
  "status": "running"
}
```

This does not mean execution has completed.

---

### Run States

A run can transition through the following states:

* `scheduled`
* `running`
* `waiting` (human review or input)
* `completed`
* `failed`
* `cancelled`

Run state is queryable at any time.

---

## Retrieving Run Status & Outputs

### Get Run Details

```bash
curl "$SUPERVITY_API_URL/api/v1/workflow-runs/run_abc123" \
  -H "Authorization: Bearer $SUPERVITY_TOKEN"
```

Typical response:

```json
{
  "runId": "run_abc123",
  "status": "completed",
  "outputs": {
    "summary": "This document outlines...",
    "confidence": 0.92
  },
  "startedAt": "...",
  "completedAt": "..."
}
```

Outputs reflect the final workflow state.

---

## Monitoring Execution Programmatically

### Polling (Simple)

You can poll until the run reaches a terminal state:

```
GET /api/v1/workflow-runs/:runId
```

Recommended for:

* background jobs
* batch execution
* simple backend integrations

---

### Streaming (Recommended for Interactive Use)

For real-time visibility, use chat-based streaming APIs.

Streaming supports:

* execution progress
* step-level updates
* planner events
* human review interrupts
* resume signals

→ see: **[Chat & Streaming APIs](./api-reference.md#chats-threads--messages)**

---

## Human Review & Interrupts

If a workflow includes human review steps:

* execution transitions to `waiting`
* the run pauses safely
* a human action is required
* execution resumes after action

API-triggered runs behave exactly like UI-triggered runs.

→ see: **[Human-in-Command APIs](./human-in-command.md)**

---

## Error Handling

If execution fails, the run object includes:

* failure reason
* step where the failure occurred
* error message
* retry eligibility

Failures:

* do not corrupt workflows
* do not affect future runs
* are fully logged and auditable

---

## Permissions & Authentication

Execution is governed by:

* token scopes
* workspace role permissions
* integration access
* policy rules

If execution fails due to permissions, the response clearly indicates the violation.

---

## Common Integration Patterns

### Agent as a Backend Service

* backend triggers agent execution
* agent performs reasoning and orchestration
* outputs returned to backend
* approvals and governance still apply

---

### Event-Driven Execution

* external system emits event
* backend or webhook triggers run
* agent processes event payload
* results stored or forwarded

---

### Batch or Scheduled Execution

* combine scheduling with api-triggered runs
* treat agents as reliable jobs
* monitor execution programmatically

---

## Where to Go Next

* approvals & interrupts → **[Human-in-Command APIs](./human-in-command.md)**
* streaming execution → **[API Reference](./api-reference.md)**
* tool registration → **[Tooling & External APIs](./tooling.md)**

---

Agent execution APIs allow you to treat Supervity agents as **governed, observable services** — not opaque ai calls.

```
